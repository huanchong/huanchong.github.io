<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=6.7.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.7.0',
    sidebar: {"position":"left","width":350,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Huanchong&#39;s Blog">
<meta property="og:url" content="http://huanchong.top/index.html">
<meta property="og:site_name" content="Huanchong&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Huanchong&#39;s Blog">






  <link rel="canonical" href="http://huanchong.top/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Huanchong's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Huanchong's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://huanchong.top/2019/04/26/js-high-level/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Huanchong Zhang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huanchong's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/26/js-high-level/" class="post-title-link" itemprop="url">js高级特性</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-26 15:26:04" itemprop="dateCreated datePublished" datetime="2019-04-26T15:26:04+08:00">2019-04-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-28 20:16:09" itemprop="dateModified" datetime="2019-04-28T20:16:09+08:00">2019-04-28</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>let\const 声明的变量，在块级作用域中可见</li>
<li>var声明的变量，在函数作用域中可见</li>
<li>最外层是全局作用域，node环境中全局对象为global，浏览器环境中全局对象为window</li>
<li>作用域链，当当前作用域内查找不到同名变量时，会去外层作用域中查找</li>
<li>函数作用域是静态作用域(词法作用域)，也就是说函数作用域的嵌套父子关系是在函数定义的时候，就确定了，而不是在函数调用的时候才确定<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'top'</span>;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(scope);</span><br><span class="line">&#125;;</span><br><span class="line">f1(); <span class="comment">// 输出 top</span></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">'f2'</span>; </span><br><span class="line">    f1();</span><br><span class="line">&#125;;</span><br><span class="line">f2(); <span class="comment">// 输出 top</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>当一个函数返回它内部定义的一个函数时，就产生了一个闭包， 闭包不但包括被返回的函数，还包括这个函数的定义环境<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> generateClosure = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> get = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">return</span> count; </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> get; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> counter1 = generateClosure(); </span><br><span class="line"><span class="keyword">var</span> counter2 = generateClosure(); </span><br><span class="line"><span class="built_in">console</span>.log(counter1()); <span class="comment">// 输出 1 </span></span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 输出 1 </span></span><br><span class="line"><span class="built_in">console</span>.log(counter1()); <span class="comment">// 输出 2 </span></span><br><span class="line"><span class="built_in">console</span>.log(counter1()); <span class="comment">// 输出 3 </span></span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上面这个例子解释了闭包是如何产生的:counter1 和 counter2 分别调用了 generate- Closure() 函数，生成了两个闭包的实例，它们内部引用的 count 变量分别属于各自的 运行环境。<strong>我们可以理解为，在 generateClosure() 返回 get 函数时，私下将 get 可 能引用到的 generateClosure() 函数的内部变量(也就是 count 变量)也返回了，并在内存中生成了一个副本</strong>，之后 generateClosure() 返回的函数的两个实例 counter1 和 counter2 就是相互独立的了。</p>
</blockquote>
<h4 id="闭包的用途：实现对象的私有成员"><a href="#闭包的用途：实现对象的私有成员" class="headerlink" title="闭包的用途：实现对象的私有成员"></a>闭包的用途：实现对象的私有成员</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateClosure = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>; <span class="comment">//私有变量</span></span><br><span class="line">    <span class="keyword">var</span> get = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">return</span> count; </span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">return</span> get;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> counter = generateClosure(); </span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 输出 1 </span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 输出 2 </span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>
<p>在函数中通过返回一个子函数，对外部暴露一个访问和更新内部变量的接口，外部不能直接访问函数作用域内的变量，完成了对变量私有化的隐藏</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="访问对象属性成员方式"><a href="#访问对象属性成员方式" class="headerlink" title="访问对象属性成员方式"></a>访问对象属性成员方式</h4><ul>
<li>点运算符（obj.a）</li>
<li>关联数组（obj[‘a’]）,使用关联数组的优势是可以使用变量作为索引，这对于我们前期不知道对象属性key的时候非常有用<h4 id="上下文对象this"><a href="#上下文对象this" class="headerlink" title="上下文对象this"></a>上下文对象this</h4></li>
<li>上下文对象就是 this 指针，即被调用函数所处的环境</li>
<li>JavaScript 的任何函数都是被某个对象调用的，在最外部全局作用域中，调用它的是全局对象</li>
<li><p>this 指针不属于某个函数，而是函数调用时所属的对象。也就是说谁调用的函数，this就指向谁</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someuser = &#123; </span><br><span class="line">    name: <span class="string">'Tom'</span>, </span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;; </span><br><span class="line">  <span class="keyword">var</span> foo = &#123; </span><br><span class="line">      name: <span class="string">'foobar'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  someuser.func(); <span class="comment">// 输出 Tom</span></span><br><span class="line"></span><br><span class="line">  foo.func = someuser.func; </span><br><span class="line">  foo.func(); <span class="comment">// 输出 foobar</span></span><br><span class="line"></span><br><span class="line">  name = <span class="string">'global'</span>;</span><br><span class="line">  func = someuser.func; </span><br><span class="line">  func(); <span class="comment">// 输出 global</span></span><br></pre></td></tr></table></figure>
<p>在 JavaScript 中，本质上，函数类型的变量是指向这个函数实体的一个引用，在引用之间赋值不会对对象产生复制行为。我们可以通过函数的任何一个引用调用这个函数，不同之处仅仅在于上下文</p>
<ul>
<li>改变函数中上下文对象的方式：<ul>
<li>call，以依次列举参数形式，传递给被调函数参数 func.call(thisArg[, arg1[, arg2[, …]]])，<strong>返回被调函数执行结果</strong></li>
<li>apply，以传递数组的形式，传递给被调函数参数 func.apply(thisArg[, argsArray])，<strong>返回被调函数执行结果</strong></li>
<li>bind，func.bind(thisArg[, arg1[, arg2[, …]]]) <strong>返回绑定新的上下文对象的函数</strong>，以后调用时都是固定绑定的上下文对象，会重复调用时适合使用bind方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>使用原型和构造函数初始化对象属性的区别：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'Tom'</span>; </span><br><span class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(); </span><br><span class="line">person.showName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Tom'</span>;</span><br><span class="line">    <span class="keyword">this</span>.showNmae = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(); </span><br><span class="line">person.showName();</span><br></pre></td></tr></table></figure></p>
<ol>
<li>继承方式不同：原型方式，子对象通过原型链可以直接访问父对象的属性；构造函数内定义的属性，子对象必须显式调用父对象才能访问</li>
<li>原型定义的属性和方法是子对象实例共用一套，减少重复开销；构造函数内定义的属性，每次新建一个对象实例，都会在内存中重新创建一套，实例之间不共享</li>
<li>对象的成员函数最好使用原型方式定义，可以减少内存开销；定义在构造函数内部，多个对象会重复创建，同时可能会有运行时闭包开销</li>
<li>一般的变量属性成员，在构造函数中定义，保证每个实例对象数据的独立性，因为在原型上定义意味着所有实例共享这一个，任何对象的主动更改会影响到其他实例对象</li>
</ol>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><ol>
<li>JavaScript 中有两个特殊的对象: Object 与 Function，它们都是构造函数，用于生<br>成对象</li>
<li>Object.prototype 是所有对象的祖先，Function.prototype 是所有函数的原型，包括构造函数</li>
<li>JavaScript 中的对象分为三类，一类是用户创建的对象，一类是构造函数对象，一类是原型对象<ul>
<li>用户创建的对象，即一般意义上用 new 语句显式构造获得的对象</li>
<li>构造函数对象指的是普通的构造函数，即通过 new 调用生成普通对象的那个函数</li>
<li>原型对象 特指构造函数 prototype 属性指向的对象</li>
</ul>
</li>
<li>这三类对象中每一类都有一个 <strong>proto</strong> 属 性，它指向该对象的原型，从任何对象沿着它开始遍历都可以追溯到 Object.prototype</li>
<li>构造函数对象有 prototype 属性，指向原型对象；通过该构造函数创建对象时，被创建的普通对象的 <strong>proto</strong> 属性将会指向构造函数的 prototype 属性，也就是该普通对象的原型对象</li>
<li>原型对象有 constructor 属性，指向它对应的构造函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.name = <span class="string">'My Object'</span>; Foo.prototype.name = <span class="string">'Bar'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// 输出 My Object</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.name); <span class="comment">// 输出 Bar</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__.name); <span class="comment">// 输出 Bar </span></span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__.__proto__.name); <span class="comment">// 输出 My Object </span></span><br><span class="line"><span class="built_in">console</span>.log(foo. __proto__.constructor.prototype.name); <span class="comment">// 输出 Bar</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g2i5w8jfmuj214k0tsq9o.jpg" alt=""></p>
<ol>
<li>在 JavaScript 中，继承是依靠一套叫做原型链(prototype chain)的机制实现的。</li>
<li>属性 继承的本质就是一个对象可以访问到它的原型链上任何一个原型对象的属性</li>
</ol>
<h3 id="原型的深拷贝"><a href="#原型的深拷贝" class="headerlink" title="原型的深拷贝"></a>原型的深拷贝</h3><p>日常开发中，如果只需要复制基本的属性时(基本类型、对象、数组等，不包含函数与特殊对象new Date()、正则等)，使用JSON序列化再反序列化的方法是最便捷的方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br></pre></td></tr></table></figure></p>
<h4 id="如果想要支持成员函数的拷贝："><a href="#如果想要支持成员函数的拷贝：" class="headerlink" title="如果想要支持成员函数的拷贝："></a>如果想要支持成员函数的拷贝：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.clone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span>(<span class="keyword">this</span>[i]) == <span class="string">'object'</span> || <span class="keyword">typeof</span>(<span class="keyword">this</span>[i]) == <span class="string">'function'</span>) &#123; </span><br><span class="line">        newObj[i] = <span class="keyword">this</span>[i].clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newObj[i] = <span class="keyword">this</span>[i];</span><br><span class="line">    &#125; &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.clone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArray = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span>(<span class="keyword">this</span>[i]) == <span class="string">'object'</span> || <span class="keyword">typeof</span>(<span class="keyword">this</span>[i]) == <span class="string">'function'</span>) &#123; </span><br><span class="line">        newArray[i] = <span class="keyword">this</span>[i].clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newArray[i] = <span class="keyword">this</span>[i];</span><br><span class="line">    &#125; &#125;</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.clone = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> newFun = <span class="function"><span class="keyword">function</span> <span class="title">newFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> that.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">//这里构成了闭包</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">    newFun[i] = <span class="keyword">this</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newFun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环引用的深拷贝"><a href="#循环引用的深拷贝" class="headerlink" title="循环引用的深拷贝"></a>循环引用的深拷贝</h4><ul>
<li>使用JSON序列化反序列化会报错<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g2iled3rujj20y00fstas.jpg" alt=""></li>
<li>使用上面常规的递归方式会出现死循环，最后栈溢出<h4 id="解决方案：引入WeakMap结构"><a href="#解决方案：引入WeakMap结构" class="headerlink" title="解决方案：引入WeakMap结构"></a>解决方案：引入WeakMap结构</h4>WeakMap对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的<br>遍历对象时使用WeakMap结构存储，遇到循环引用的对象，通过WeakMap.prototype.has(key)与WeakMap.prototype.get(key)来终止循环遍历问题<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &amp;&amp; obj !== <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj, mapObj = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mapObj.has(obj)) <span class="keyword">return</span> mapObj.get(obj)</span><br><span class="line">    <span class="keyword">let</span> cloneObj = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;</span><br><span class="line">    mapObj.set(obj, cloneObj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        cloneObj[key] = isObj(obj[key]) ? deepCopy(obj[key], mapObj) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://huanchong.top/2019/04/24/nodeJS-4/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Huanchong Zhang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huanchong's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/24/nodeJS-4/" class="post-title-link" itemprop="url">nodeJS番外篇</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-24 20:59:40" itemprop="dateCreated datePublished" datetime="2019-04-24T20:59:40+08:00">2019-04-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-26 15:13:04" itemprop="dateModified" datetime="2019-04-26T15:13:04+08:00">2019-04-26</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><h4 id="模块的类型"><a href="#模块的类型" class="headerlink" title="模块的类型"></a>模块的类型</h4><ul>
<li>node内置的核心模块（http\fs\net\vm）</li>
<li>第三方的文件模块（npm安装、本地文件模块）<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g2e14d6teaj216a0843zp.jpg" alt=""><h4 id="模块加载-require"><a href="#模块加载-require" class="headerlink" title="模块加载 require()"></a>模块加载 require()</h4></li>
<li><p>加载模块名：首先先查找同名内置核心模块，如果没有则查找 node_modules 目录加载模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br></pre></td></tr></table></figure>
<p>当 require 遇到一个既不是核心模块，又不是以路径形式表示的模块名称时，会试图在当前目录下的 node_modules 目录中来查找是不是有这样一个模块。如果没有找到，则会在当前目录的上一层中的 node_modules 目录中继续查找，反复执行这一过程，直到遇到根目录为止</p>
</li>
<li>按路径加载，在不显式指定文件模块扩展名的时候，Node.js 会分别试图加上 .js、.json 和 .node扩展名</li>
</ul>
<h4 id="加载缓存"><a href="#加载缓存" class="headerlink" title="加载缓存"></a>加载缓存</h4><ul>
<li>Node.js 对于已经加载过的文件模块，会缓存在内存中，以后多次require引用时，直接从内存中获取</li>
<li>通过文件名缓存所有加载过的文件模块，而不是 require() 提供的参数缓存的，也就是说即使你分别通过 require(‘express’) 和 require(‘./node_modules/express’) 加载两次，也不会重 复加载，因为尽管两次参数不同，解析到的文件却是同一个</li>
</ul>
<h3 id="Node-js应用部署"><a href="#Node-js应用部署" class="headerlink" title="Node.js应用部署"></a>Node.js应用部署</h3><ul>
<li>故障恢复的能力</li>
<li>日志（访问日志与 错误日志）</li>
<li>利用多核提升性能</li>
<li><p>共享同一端口(设置web服务器反向代理+虚拟主机)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name mysite.com; #虚拟主机名</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:3000;  #设置反向代理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供自动重启服务的能力（代码有部署更新时，无需手动重启）</p>
</li>
</ul>
<h3 id="Node-js不适合做的服务"><a href="#Node-js不适合做的服务" class="headerlink" title="Node.js不适合做的服务"></a>Node.js不适合做的服务</h3><ul>
<li>计算密集型的服务：node.js单线程+事件驱动的异步编程方式，当遇到计算量很大的事件时，往往会阻塞队列中后续的响应事件，对于多核资源利用效率不高</li>
<li>单用户多任务型应用：需要同时执行多个任务在多个进程时，多进程之间的协作不够便捷</li>
<li>逻辑十分复杂的事务：对于线性且多步骤复杂的操作，其中一个步骤失败都需要回滚到最初状态。Node.js更善于处理那些逻辑简单但访问频繁的任务，而不适合完成逻辑十分复杂的工作</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://huanchong.top/2019/04/20/nodeJS-3/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Huanchong Zhang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huanchong's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/20/nodeJS-3/" class="post-title-link" itemprop="url">nodeJS网站搭建</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-20 21:08:38" itemprop="dateCreated datePublished" datetime="2019-04-20T21:08:38+08:00">2019-04-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-24 21:00:42" itemprop="dateModified" datetime="2019-04-24T21:00:42+08:00">2019-04-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="node-js搭建网站"><a href="#node-js搭建网站" class="headerlink" title="node.js搭建网站"></a>node.js搭建网站</h3><p>网站架构：MVC设计模式（模型、视图、控制器）</p>
<ul>
<li>模型是对象及其数据结构的实现，通常包含数据库操作。</li>
<li>视图表示用户界面，在网站中通常就是 HTML 的组织结构。</li>
<li>控制器用于处理用户请求和数据流、复杂模型，将输出传递给视图</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g29euoz7xtj20l80g0t9x.jpg" alt=""><br>使用Express框架、ejs模板引擎、MongoDB 数据库 搭建web网站：<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g29ewf17hfj20hk0oo0u8.jpg" alt=""></p>
<ul>
<li>express中的路由控制器，作为C</li>
<li>ejs模板引擎，作为V</li>
<li>操作数据库的数据对象模型，作为M<h4 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h4></li>
<li>提供诸多中间件，用于组织构建网站</li>
<li>提供路由功能，作为控制器，处理请求过来的逻辑，并将最终结果返回给客户端</li>
</ul>
<h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><p>控制器得到用户请求后，从模型获取数据，调用模板引擎。模板引擎以数据和页面模板为输入，生成 HTML 页面，然后返回给控制器，由控制器交回客户端<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g29f622qx6j20o60gg3zw.jpg" alt=""></p>
<h4 id="数据库MongoDB"><a href="#数据库MongoDB" class="headerlink" title="数据库MongoDB"></a>数据库MongoDB</h4><ul>
<li>开源的NoSQL数据库，相比 MySQL 那样的关系型数据库，它更为轻巧、灵活，非常适合在数据规模很大、事务性不强的场合下使用</li>
<li>被称为对象数据库，没有传统sql的表和行等概念</li>
<li>所有的数据由一个大的文档对象组成，属性值的存取也非常灵活</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://huanchong.top/2019/04/15/nodeJS-2/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Huanchong Zhang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huanchong's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/15/nodeJS-2/" class="post-title-link" itemprop="url">nodeJS核心模块</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-15 13:31:26" itemprop="dateCreated datePublished" datetime="2019-04-15T13:31:26+08:00">2019-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-24 21:00:27" itemprop="dateModified" datetime="2019-04-24T21:00:27+08:00">2019-04-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><h3 id="全局对象与全局变量"><a href="#全局对象与全局变量" class="headerlink" title="全局对象与全局变量"></a>全局对象与全局变量</h3><ul>
<li>node环境中，全局对象为global；浏览器环境中，全局对象时window</li>
<li>所有全局变量均挂载在全局对象上，作为全局对象的属性，其中包含：<ul>
<li>显式定义全局对象的属性</li>
<li>隐式定义的变量(没有定义直接赋值的变量)</li>
<li>这里建议使用 var、let、const 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。<h4 id="常用的全局变量"><a href="#常用的全局变量" class="headerlink" title="常用的全局变量"></a>常用的全局变量</h4>process：描述当前 Node.js 进程状态 的对象，提供了一个与操作系统的简单接口</li>
</ul>
</li>
<li>process.argv是命令行参数数组，第一个元素是 node，第二个元素是脚本文件名，从第三个元素开始每个元素是一个运行参数</li>
<li>process.nextTick(callback)将callback放入异步micro task队列中，如果callback的执行时间需要很长，则通过这个方式可以不阻塞当前主线程<br>console:控制台标准输出</li>
<li>console.log()常规输出，也可以使用类似c语言printf()命令的占位符输出console.log(‘%d year’, 1993)</li>
<li>console.error()输出错误</li>
<li>console.trace()输出当前调用栈</li>
</ul>
<h3 id="事件驱动-events模块"><a href="#事件驱动-events模块" class="headerlink" title="事件驱动 events模块"></a>事件驱动 events模块</h3><p>事件发射与监听器：events.EventEmitter 对象</p>
<ul>
<li>EventEmitter.on(event, listener) 为指定事件注册一个监听器，接受一个字符串event 和一个回调函数listener</li>
<li>EventEmitter.emit(event, [arg1], [arg2], […]) 发射 event 事件，传递若干可选参数到事件监听器的参数表</li>
<li>EventEmitter.once(event, listener) 为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器</li>
<li>EventEmitter.removeListener(event, listener) 移除指定事件的某个监听器，listener 必须是该事件已经注册过的监听器</li>
<li>EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器， 如果指定 event，则移除指定事件的所有监听器<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line">emitter.on(<span class="string">'event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'listener1'</span>, arg1, arg2);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.on(<span class="string">'event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'listener2'</span>, arg1, arg2);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.emit(<span class="string">'someEvent'</span>, <span class="string">'hello'</span>, <span class="string">'world'</span>);</span><br><span class="line"><span class="comment">// listener1 hello world</span></span><br><span class="line"><span class="comment">// listener2 hello world</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类，<strong>模块的实例对象可以直接使用on()方法监听事件</strong></p>
</blockquote>
<h3 id="文件系统-fs模块"><a href="#文件系统-fs模块" class="headerlink" title="文件系统 fs模块"></a>文件系统 fs模块</h3><ul>
<li>fs.readFile() 异步读取文件内容</li>
<li>fs.readFileSync() 同步读取文件内容</li>
<li>fs.open() 打开文件</li>
<li>fs.read() 读取文件(从指定的文件描述符 fd 中读取数据并写入 buffer 指向的缓冲区对象)，需要先执行fs.open()打开文件后，在其回调函数中使用fs.read().一般来说，除非必要，否则不要使用这种方式读取文件，因为它要求你手动管理缓冲区 和文件指针，尤其是在你不知道文件大小的时候，这将会是一件很麻烦的事情。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.open(<span class="string">'content.txt'</span>, <span class="string">'r'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">8</span>);</span><br><span class="line">fs.read(fd, buf, <span class="number">0</span>, <span class="number">8</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytesRead, buffer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123; </span><br><span class="line">        <span class="built_in">console</span>.error(err); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'bytesRead: '</span> + bytesRead);</span><br><span class="line">        <span class="built_in">console</span>.log(buffer);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// bytesRead: 8</span></span><br><span class="line"><span class="comment">// &lt;Buffer 54 65 78 74 20 e6 96 87&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="HTTP-模块"><a href="#HTTP-模块" class="headerlink" title="HTTP 模块"></a>HTTP 模块</h3><p>HTTP模块封装了一个HTTP服务器与HTTP客户端</p>
<h4 id="HTTP服务器（基于http-Server对象实现）"><a href="#HTTP服务器（基于http-Server对象实现）" class="headerlink" title="HTTP服务器（基于http.Server对象实现）"></a>HTTP服务器（基于http.Server对象实现）</h4><p>http.createServer()会创建一个http.Server实例对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;); </span><br><span class="line">    res.write(<span class="string">'&lt;h1&gt;Node.js&lt;/h1&gt;'</span>);</span><br><span class="line">    res.end(<span class="string">'&lt;p&gt;Hello World&lt;/p&gt;'</span>);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"HTTP server is listening at port 3000."</span>);</span><br></pre></td></tr></table></figure></p>
<p>http.createServer的回调函数中的两个参数 req 和res，分别是 http.ServerRequest和http.ServerResponse 的实例，表示请求和响应信息</p>
<h5 id="http-ServerRequest-是-HTTP-请求的信息，所有的业务逻辑都是根据请求传递的内容展开的，所以是后端开发者最关注的内容"><a href="#http-ServerRequest-是-HTTP-请求的信息，所有的业务逻辑都是根据请求传递的内容展开的，所以是后端开发者最关注的内容" class="headerlink" title="http.ServerRequest 是 HTTP 请求的信息，所有的业务逻辑都是根据请求传递的内容展开的，所以是后端开发者最关注的内容"></a>http.ServerRequest 是 HTTP 请求的信息，所有的业务逻辑都是根据请求传递的内容展开的，所以是后端开发者最关注的内容</h5><p>包含一些常用属性：<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g25hbftx9rj21760j2gpa.jpg" alt=""><br>http.ServerRequest的事件：</p>
<ul>
<li>data :当请求体数据到来时，该事件被触发。该事件提供一个参数 chunk，表示接 收到的数据。如果该事件没有被监听，那么请求体将会被抛弃。该事件可能会被调 用多次</li>
<li>end :当请求体数据传输完成时，该事件被触发，此后将不会再有数据到来</li>
<li>close: 用户当前请求结束时，该事件被触发</li>
</ul>
<h6 id="获取GET请求内容：使用url-parse来解析get请求中url后面的参数"><a href="#获取GET请求内容：使用url-parse来解析get请求中url后面的参数" class="headerlink" title="获取GET请求内容：使用url.parse来解析get请求中url后面的参数"></a>获取GET请求内容：使用url.parse来解析get请求中url后面的参数</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>); </span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>); </span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;); </span><br><span class="line">    res.end(util.inspect(url.parse(req.url, <span class="literal">true</span>))); <span class="comment">// util.inspect是将对象转换成字符串的工具函数</span></span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<h6 id="获取POST请求内容"><a href="#获取POST请求内容" class="headerlink" title="获取POST请求内容"></a>获取POST请求内容</h6><p>使用http.ServerRequest的data事件收集post请求体内容，然后使用querystring.parse来解析post请求传过来的内容<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>); </span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> post = <span class="string">''</span>;</span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123; </span><br><span class="line">        post += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        post = querystring.parse(post); </span><br><span class="line">        res.end(util.inspect(post));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p> 不要在真正的生产应用中使用上面这种简单的方法来获取 POST 请 求，因为它有严重的效率问题和安全问题，这只是一个帮助你理解的示例。</p>
</blockquote>
<h5 id="http-ServerResponse-是返回给客户端的信息，决定了用户最终能看到的结果"><a href="#http-ServerResponse-是返回给客户端的信息，决定了用户最终能看到的结果" class="headerlink" title="http.ServerResponse 是返回给客户端的信息，决定了用户最终能看到的结果"></a>http.ServerResponse 是返回给客户端的信息，决定了用户最终能看到的结果</h5><p>三个重要的成员函数，用于返回响应头、响应内容以及结束 请求:</p>
<ul>
<li>response.writeHead(statusCode, [headers]):向请求的客户端发送响应头。 statusCode 是 HTTP 状态码，如 200 (请求成功)、404 (未找到)等。headers 是一个类似关联数组的对象，表示响应头的每个属性。该函数在一个请求内最多只 能调用一次，如果不调用，则会自动生成一个响应头</li>
<li>response.write(data, [encoding]):向请求的客户端发送响应内容。data 是 一个 Buffer 或字符串，表示要发送的内容。如果 data 是字符串，那么需要指定 encoding 来说明它的编码方式，默认是 utf-8。在 response.end 调用之前， response.write 可以被多次调用</li>
<li>response.end([data], [encoding]):结束响应，告知客户端所有发送已经完 成。当所有要返回的内容发送完毕的时候，该函数 必须 被调用一次。它接受两个可 选参数，意义和 response.write 相同。如果不调用该函数，客户端将永远处于 等待状态</li>
</ul>
<h4 id="HTTP-客户端（作为客户端向服务器发起请求）"><a href="#HTTP-客户端（作为客户端向服务器发起请求）" class="headerlink" title="HTTP 客户端（作为客户端向服务器发起请求）"></a>HTTP 客户端（作为客户端向服务器发起请求）</h4><ul>
<li><p>http.request(options, callback) 发起 HTTP 请求</p>
<ul>
<li>option 是 一个类似关联数组的对象，表示请求的参数，callback 是请求的回调函数</li>
<li>callback 传递一个参数，为http.ClientResponse的实例</li>
<li>http.request 返回一个http.ClientRequest的实例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> contents = querystring.stringify(&#123;</span><br><span class="line">name: <span class="string">'byvoid'</span>,</span><br><span class="line">email: <span class="string">'byvoid@byvoid.com'</span>,</span><br><span class="line">address: <span class="string">'Zijing 2#, Tsinghua University'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">host: <span class="string">'www.byvoid.com'</span>,</span><br><span class="line">path: <span class="string">'/application/node/post.php'</span>, <span class="attr">method</span>: <span class="string">'POST'</span>,</span><br><span class="line">headers: &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">        <span class="string">'Content-Length'</span> : contents.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> req = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123; res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">req.write(contents);</span><br><span class="line">req.end(); <span class="comment">//  不要忘了通过 req.end() 结束请求，否则服务器将不会收到信息</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>http.get(options, callback) get请求的简化版，唯一的区别在于http.get 自动将请求方法设为了 GET 请求，同时<strong>不需要手动调用 req.end()</strong></p>
</li>
</ul>
<h5 id="http-ClientRequest-对象（http-request-返回的实例对象）"><a href="#http-ClientRequest-对象（http-request-返回的实例对象）" class="headerlink" title="http.ClientRequest 对象（http.request()返回的实例对象）"></a>http.ClientRequest 对象（http.request()返回的实例对象）</h5><p>对象含有的方法：</p>
<ul>
<li>write()服务器发送请求体</li>
<li>end()写结束以后必须调用 end 函数以通知服务器，否则请求无效</li>
</ul>
<h5 id="http-ClientResponse-对象（http-request-回调函数中的参数为该实例对象）"><a href="#http-ClientResponse-对象（http-request-回调函数中的参数为该实例对象）" class="headerlink" title="http.ClientResponse 对象（http.request()回调函数中的参数为该实例对象）"></a>http.ClientResponse 对象（http.request()回调函数中的参数为该实例对象）</h5><p>提供三个事件：</p>
<ul>
<li>data 数据达到是触发</li>
<li>end 数据传输结束后触发</li>
<li>close 连接结束后触发<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g25puxxjy2j216q09sgn9.jpg" alt=""></li>
</ul>
<p>三个特殊的函数：</p>
<ul>
<li>response.setEncoding([encoding]):设置默认的编码，当 data 事件被触发时，数据将会以 encoding 编码。默认值是 null，即不编码，以 Buffer 的形式存储。常用编码为 utf8</li>
<li>response.pause():暂停接收数据和发送事件，方便实现下载功能</li>
<li>response.resume():从暂停的状态中恢复</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://huanchong.top/2019/04/14/nodeJS-1/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Huanchong Zhang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huanchong's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/14/nodeJS-1/" class="post-title-link" itemprop="url">nodeJS入门指南</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-14 12:49:38" itemprop="dateCreated datePublished" datetime="2019-04-14T12:49:38+08:00">2019-04-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-24 21:00:31" itemprop="dateModified" datetime="2019-04-24T21:00:31+08:00">2019-04-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="node-js简介"><a href="#node-js简介" class="headerlink" title="node.js简介"></a>node.js简介</h3><ul>
<li>node.js不是一种独立语言，是一个可以让js在服务器端运行的平台</li>
<li>区别与传统语言平台依靠多线程来实现高并发的设计思路，node采用单线程、异步式I/O、事件驱动式的程序设计模型</li>
<li>node.js使用的JavaScript引擎为V8引擎，还使用了高效的 <strong>libev 和 libeio 库支持事件驱动和异步式 I/O</strong> 来代替传统平台的多线程模式，带来性能的提升（传统多线程模式对于 高并发的访问，一方面线程长期阻塞等待，另一方面为了应付新请求而不断增加线程，因此 会浪费大量系统资源，同时线程的增多也会占用大量的 CPU 时间来处理内存上下文切换， 而且还容易遭受低速连接攻击。）</li>
<li>有别于php等语言，在使用php构建web服务时，必须外部依赖一个Nginx、Apache等http服务器，然后通过http服务区的模块加载或CGI调用，才能将php的执行结果呈现给用户；而node.js内置了http服务器模块，无需再额外搭建</li>
<li>node.js可以调用c/c++代码，对于性能要求比较高的模块可以使用c/c++来实现<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g2242fwxptj20wm0mign9.jpg" alt=""></li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g224ukryq5j20l00gcdgz.jpg" alt=""></p>
<p>node.js只在第一次运行时会读取文件内容，以后都会直接访问内存，也就是当文件实时改动时，不会触发重新编译文件内容，所以需要使用<strong>supervisor、pm2</strong>等工具，对node服务进行实时管理</p>
<h3 id="异步式I-O-与事件驱动式编程"><a href="#异步式I-O-与事件驱动式编程" class="headerlink" title="异步式I/O 与事件驱动式编程"></a>异步式I/O 与事件驱动式编程</h3><h4 id="阻塞与线程"><a href="#阻塞与线程" class="headerlink" title="阻塞与线程"></a>阻塞与线程</h4><blockquote>
<p>什么是阻塞(block)呢?线程在执行中如果遇到磁盘读写或网络通信(统称为 I/O 操作)， 通常要耗费较长的时间，这时操作系统会剥夺这个线程的 CPU 控制权，使其暂停执行，同 时将资源让给其他的工作线程，这种线程调度方式称为 阻塞。当 I/O 操作完毕时，操作系统 将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。这种 I/O 模式就是通 常的同步式 I/O(Synchronous I/O)或阻塞式 I/O (Blocking I/O)  </p>
</blockquote>
<blockquote>
<p>异步式 I/O (Asynchronous I/O)或非阻塞式 I/O (Non-blocking I/O)则针对 所有 I/O 操作不采用阻塞的策略。<strong>当线程遇到 I/O 操作时，不会以阻塞的方式等待 I/O 操作 的完成或数据的返回，而只是将 I/O 请求发送给操作系统，继续执行下一条语句</strong>。当操作 系统完成 I/O 操作时，以<strong>事件的形式</strong>通知执行 I/O 操作的线程，线程会在特定时候处理这个 事件。为了处理异步 I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予 以处理。</p>
</blockquote>
<h4 id="多线程与单线程的比较："><a href="#多线程与单线程的比较：" class="headerlink" title="多线程与单线程的比较："></a>多线程与单线程的比较：</h4><p>对于需要长时间计算的I/O处理操作</p>
<ul>
<li><p>多线程模式：如果想实现高并发，就必须开启多个线程<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g225j31u3mj20qu0oiaci.jpg" alt=""></p>
</li>
<li><p>单线程模式：I/O异步，通过事件方式通知线程，即可完成高并发<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g225kaxr3sj20po0swju4.jpg" alt=""></p>
</li>
</ul>
<p>单线程事件驱动的异步式 I/O 比传统的多线程阻塞式 I/O 究竟好在哪里呢?</p>
<ul>
<li>简而言之， 异步式 I/O 就是少了多线程的开销。对操作系统来说，创建一个线程的代价是十分昂贵的， 需要给它分配内存、列入调度，同时在线程切换的时候还要执行内存换页，CPU 的缓存被 清空，切换回来的时候还要重新从内存中读取信息，破坏了数据的局部性。(基于多线程的模型也有相应的解决方案，如轻量级线程(lightweight thread)等。事件驱动的单线程异步模型与多线 程同步模型到底谁更好是一件非常有争议的事情，因为尽管消耗资源，后者的吞吐率并不比前者低)</li>
<li>异步式编程的缺点在于不符合人们一般的程序设计思维，存在回调地狱的情况（使用async、promise等编写方式）<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g225r057v1j216k0ceada.jpg" alt=""></li>
</ul>
<h3 id="node-js的事件循环机制"><a href="#node-js的事件循环机制" class="headerlink" title="node.js的事件循环机制"></a>node.js的事件循环机制</h3><blockquote>
<p>Node.js 程序由事件循环开始，到事件循环结束，所有的逻辑都是事件的回调函数，所以 Node.js 始终在事件循环中，程序入口就是 事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出 I/O 请求或 直接发射(emit)事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未 处理的事件，直到程序结束.</p>
<p>与其他语言不同的是，Node.js 没有显式的事件循环，类似 Ruby 的 EventMachine::run() 的函数在 Node.js中是不存在的。Node.js的事件循环对开发者不可见，由libev库实现。libev支持多种类型的事件，如 ev_io、ev_timer、ev_signal、ev_idle 等，在 Node.js 中均被 EventEmitter 封装。libev 事件循环的每一次迭代，在 Node.js 中就是一次 Tick，libev 不 断检查是否有活动的、可供检测的事件监听器，直到检测不到时才退出事件循环，进程结束</p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g22cm3qesvj20ps0s4q59.jpg" alt=""></p>
<h3 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h3><h4 id="创建npm包"><a href="#创建npm包" class="headerlink" title="创建npm包"></a>创建npm包</h4><p>Node.js 根 据 CommonJS 规范实现了包机制，开发了 npm来解决包的发布和获取需求。<br>使用如下命令初始化创建npm包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></p>
<p>Node.js 的包是一个目录，其中包含一个 JSON 格式的包说明文件 package.json。严格符 合 CommonJS 规范的包应该具备以下特征:</p>
<ul>
<li>package.json 必须在包的顶层目录下; <ul>
<li>作为npm包的描述性文件，其中常用的字段:</li>
<li><strong>main</strong>:作为包模块的入口（Node.js 在调用某个包时，会首先检查包中 package.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作 为包的接口）</li>
<li>name:包的名称</li>
<li>description:包的简要说明</li>
<li>version:版本字符串</li>
<li>keywords:关键字数组，通常用于搜索</li>
<li>maintainers:维护者数组，每个元素要包含 name、email (可选)、web (可选)字段</li>
<li>contributors:贡献者数组，格式与maintainers相同。包的作者应该是贡献者数组的第一个元素</li>
<li>bugs:提交bug的地址，可以是网址或者电子邮件地址</li>
<li>licenses:许可证数组</li>
<li>repositories:仓库托管地址数组</li>
<li>dependencies:包的依赖，一个关联数组，由包名称和版本号组成</li>
</ul>
</li>
<li>二进制文件应该在 bin 目录下;</li>
<li>JavaScript 代码应该在 lib 目录下;</li>
<li>文档应该在 doc 目录下;</li>
<li>单元测试应该在 test 目录下。<br>Node.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范 即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范</li>
</ul>
<h4 id="本地模式与全局模式"><a href="#本地模式与全局模式" class="headerlink" title="本地模式与全局模式"></a>本地模式与全局模式</h4><p>全局模式的安装：</p>
<blockquote>
<p>npm [install/i] -g [package_name]</p>
</blockquote>
<blockquote>
<p>为什么要使用全局模式呢?多数时候并不是因为许多程序都有可能用到它，为了减少多 重副本而使用全局模式，而是因为本地模式不会注册 PATH 环境变量。举例说明，我们安装 supervisor 是为了在命令行中运行它，譬如直接运行 supervisor script.js，这时就需要在 PATH 环境变量中注册 supervisor。npm 本地模式仅仅是把包安装到 node_modules 子目录下，其中 的 bin 目录没有包含在 PATH 环境变量中，不能直接在命令行中调用。而当我们使用全局模 式安装时，npm 会将包安装到系统目录，譬如 /usr/local/lib/node_modules/，同时 package.json 文 件中 bin 字段包含的文件会被链接到 /usr/local/bin/。/usr/local/bin/ 是在PATH 环境变量中默认 定义的，因此就可以直接在命令行中运行 supervisor script.js命令了</p>
</blockquote>
<p>使用全局模式安装的包并不能直接在 JavaScript 文件中用 require 获 得，因为 require 不会搜索 /usr/local/lib/node_modules/</p>
<p><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g22dbja4ptj217809emyq.jpg" alt=""><br>区别：</p>
<ul>
<li>当我们要把某个包作为工程运行时的一部分时，通过本地模式获取</li>
<li>如果要 在命令行下使用，则使用全局模式安装</li>
</ul>
<h4 id="创建全局链接"><a href="#创建全局链接" class="headerlink" title="创建全局链接"></a>创建全局链接</h4><blockquote>
<p>npm 提供了一个有趣的命令 npm link，它的功能是在本地包和全局包之间创建符号链 接。我们说过使用全局模式安装的包不能直接通过 require 使用，但通过 npm link命令 可以打破这一限制。举个例子，我们已经通过 npm install -g express 安装了 express， 5 这时在工程的目录下运行命令:<br><strong>npm link express</strong><br>./node_modules/express -&gt; /usr/local/lib/node_modules/express<br>我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当本地包来使用了</p>
</blockquote>
<blockquote>
<p>除了将全局的包链接到本地以外，使用 npm link命令还可以将本地的包链接到全局。 使用方法是在包目录( package.json 所在目录)中运行 npm link 命令。如果我们要开发 一个包，利用这种方法可以非常方便地在不同的工程间进行调试和测试</p>
</blockquote>
<h5 id="具体使用案例："><a href="#具体使用案例：" class="headerlink" title="具体使用案例："></a>具体使用案例：</h5><p>现在有两个模块，npm-link-module为我们开发的npm包；npm-link-test为我们要使用上面的npm包来做测试<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd npm-link-module  //进入开发的npm包目录里</span><br><span class="line">npm link //将本地的包链接到全局</span><br><span class="line"></span><br><span class="line">cd npm-link-test  //进入到测试项目中</span><br><span class="line">npm link npm-link-module  //将全局包npm-link-module 链接到本地node_modules路径下，这样本地就可以使用require()引用了</span><br></pre></td></tr></table></figure></p>
<h4 id="包的发布"><a href="#包的发布" class="headerlink" title="包的发布"></a>包的发布</h4><ul>
<li>npm adduser 创建账号</li>
<li>npm whoami 命令测验是否已经取得了账号</li>
<li>npm publish 发布包 </li>
<li>通过<a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a> 去搜索自己发布的包</li>
<li>日后有更新时，更改package.json中的version版本，重新npm publish即可</li>
<li>npm unpublish 取消已发布的包</li>
</ul>
<h3 id="node命令行调试-调试功能由-V8-提供"><a href="#node命令行调试-调试功能由-V8-提供" class="headerlink" title="node命令行调试(调试功能由 V8 提供)"></a>node命令行调试(调试功能由 V8 提供)</h3><p>使用node debug xxx.js 即可开启调试模式<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g22ef0cf5zj216s0x8dmr.jpg" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://huanchong.top/2019/03/05/chrome-extensions/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Huanchong Zhang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huanchong's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/05/chrome-extensions/" class="post-title-link" itemprop="url">写chrome插件前必须要知道的</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-05 15:29:08" itemprop="dateCreated datePublished" datetime="2019-03-05T15:29:08+08:00">2019-03-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-14 18:20:41" itemprop="dateModified" datetime="2019-03-14T18:20:41+08:00">2019-03-14</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>浏览器插件本质上就是利用前端的html\css\javascript等技术，借用浏览器对外提供的API，实现各种不同的功能</p>
<h3 id="插件组成"><a href="#插件组成" class="headerlink" title="插件组成"></a>插件组成</h3><p>首先先看一下我们要开发的插件的各个文件组成  </p>
<p>manifest.json :我们在项目的根文件必须要有一个命名为manifest.json的文件，它是整个插件的功能入口，用来告诉浏览器插件的一些基本信息，及需要加载和执行的资源文件等，里面包含一些必填项：</p>
<ul>
<li>name 插件的名字</li>
<li>version 插件版本</li>
<li>manifest_version manifest的版本</li>
<li><p>description 插件的描述(选填)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"hello extension"</span>,</span><br><span class="line">    <span class="string">"description"</span>: <span class="string">"Base Level Extension"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line">    <span class="string">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>icons 在扩展程序管理界面，呈现的图标，可以设置不同的尺寸的选项，用来适配不同的场景</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"icons"</span>: &#123;</span><br><span class="line">        <span class="string">"16"</span>: <span class="string">"images/extension_icon16.png"</span>,</span><br><span class="line">        <span class="string">"32"</span>: <span class="string">"images/extension_icon32.png"</span>,</span><br><span class="line">        <span class="string">"48"</span>: <span class="string">"images/extension_icon48.png"</span>,</span><br><span class="line">        <span class="string">"128"</span>: <span class="string">"images/extension_icon128.png"</span></span><br><span class="line">      &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>background 在扩展程序被开启时，会首先触发执行background 选项中指定的js资源，并且一直存在于扩展程序的整个生命周期，直到扩展程序被关闭或者删除，background一直被用来做任务和状态的控制管理工作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scripts 子选项指定了需要执行的js文件的路径及文件名</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"background"</span>: &#123;</span><br><span class="line">        <span class="string">"scripts"</span>:[<span class="string">"background.js"</span>],</span><br><span class="line">        <span class="string">"persistent"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>background.js 通常最外层使用监听事件<code>chrome.runtime.onInstalled.addListener(()=&gt;{})</code>初始化插件，监听插件安装成功后，会触发对应的逻辑开始工作</p>
<ul>
<li>permissions 属性值为一个数组，申请chrome API的权限，只有在这个选项中申请了才能使用（比如通过 XMLHttpRequest 跨域请求数据、访问浏览器选项卡（tabs）、获取当前活动选项卡（activeTab）、浏览器通知（notifications）、设置插件激活规则（declarativeContent）、类似localStorage的存储（storage）等）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"permissions"</span>: [</span><br><span class="line">        <span class="string">"http://xxx.com/api"</span></span><br><span class="line">        <span class="string">"tabs"</span>,</span><br><span class="line">        <span class="string">"activeTab"</span>,</span><br><span class="line">        <span class="string">"notifications"</span>,</span><br><span class="line">        <span class="string">"declarativeContent"</span>,</span><br><span class="line">        <span class="string">"storage"</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="与用户实现UI交互的功能主要有两个：browser-action、page-action-两者选择其中一个"><a href="#与用户实现UI交互的功能主要有两个：browser-action、page-action-两者选择其中一个" class="headerlink" title="与用户实现UI交互的功能主要有两个：browser_action、page_action 两者选择其中一个"></a>与用户实现UI交互的功能主要有两个：browser_action、page_action 两者选择其中一个</h4><ul>
<li><p>browser_action 提供的功能面向所有网站，插件图标一直是激活的状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"browser_action"</span>: &#123;</span><br><span class="line">      <span class="string">"default_popup"</span>: <span class="string">"popup.html"</span>        <span class="comment">// 指定click插件图标时，展示的页面</span></span><br><span class="line">      <span class="string">"default_icon"</span>: <span class="string">"images/icon.png"</span>, <span class="comment">// 指定浏览器工具栏展示的插件的图标 </span></span><br><span class="line">      <span class="string">"default_title"</span>: <span class="string">"display tooltip"</span> <span class="comment">// 当鼠标悬浮在插件图片上方时，展示的文字，叫tooltip；如果没有这个配置选项，则悬浮时显示menifest.json中的name选项值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>page_action 只针对对应目标网站提供的功能，插件会在background页设置激活插件的规则，只有满足条件的网页的插件才是激活的，其他网站插件是不可用的，插件的icon是灰的<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g0s0byu0w2j20mw01y3yx.jpg" alt=""><br>在<code>background script</code>里，<code>chrome.runtime.onInstalled.addListener(()=&gt;{})</code>初始化中使用<code>chrome.declarativeContent</code>定义插件被激活的规则</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"page_action"</span>:&#123;</span><br><span class="line">        <span class="string">"default_popup"</span>: <span class="string">"popup.html"</span>, <span class="comment">// 指定click插件图标时，展示的页面</span></span><br><span class="line">        <span class="string">"default_icon"</span>: <span class="string">"hello_extension.png"</span> <span class="comment">// 指定浏览器工具栏展示的插件的图标 </span></span><br><span class="line">        <span class="string">"default_title"</span>: <span class="string">"display tooltip"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    chrome.runtime.onInstalled.addListener(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Replace all rules ...</span></span><br><span class="line">    chrome.declarativeContent.onPageChanged.removeRules(<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// With a new rule ...</span></span><br><span class="line">    chrome.declarativeContent.onPageChanged.addRules([</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// That fires when a page's URL contains a 'g' ...</span></span><br><span class="line">        conditions: [</span><br><span class="line">            <span class="keyword">new</span> chrome.declarativeContent.PageStateMatcher(&#123;</span><br><span class="line">            pageUrl: &#123; <span class="attr">urlContains</span>: <span class="string">'g'</span> &#125;, <span class="comment">//url的内容中包含字母g的，插件才会被激活</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// And shows the extension's page action.</span></span><br><span class="line">        actions: [ <span class="keyword">new</span> chrome.declarativeContent.ShowPageAction() ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="popup-html"><a href="#popup-html" class="headerlink" title="popup.html"></a>popup.html</h4><p>popup.html 是使用browser_action或者page_action 指定的default_popup选项，表示点击插件图标会触发的html资源，其与普通的html页面的区别就是不能使用内联script，其他都一样<br>it can contain links to stylesheets and script tags, but does not allow inline JavaScript.</p>
<h4 id="Content-Script-对当前web页面注入扩展程序代码，也就是在当前web页面的上下文环境中，可以访问页面的DOM信息并且修改DOM，具有操作Chrome-API的权限，并且可以把信息传递给父级插件"><a href="#Content-Script-对当前web页面注入扩展程序代码，也就是在当前web页面的上下文环境中，可以访问页面的DOM信息并且修改DOM，具有操作Chrome-API的权限，并且可以把信息传递给父级插件" class="headerlink" title="Content Script 对当前web页面注入扩展程序代码，也就是在当前web页面的上下文环境中，可以访问页面的DOM信息并且修改DOM，具有操作Chrome API的权限，并且可以把信息传递给父级插件"></a>Content Script 对当前web页面注入扩展程序代码，也就是在当前web页面的上下文环境中，可以访问页面的DOM信息并且修改DOM，具有操作Chrome API的权限，并且可以把信息传递给父级插件</h4><ol>
<li>content script工作在一个独立的空间，它使得不会访问和调用web page或者其他content script中定义的变量和函数，两者唯一共享的是DOM</li>
<li><p>Content Script与Page action 或Browser action通信的方式是通过传递Message的方式，正确的机制应该是：</p>
<ul>
<li>Page action 或Browser action 中的js使用<code>chrome.tabs.sendMessage()</code>发布一个请求信息，传递出去当前的tab页id及其他信息</li>
<li><p>注意：从Page action 或Browser action发布消息到Content Script必须用<code>chrome.tabs.sendMessage()</code>，从Content Script发布简单的信息到Page action 或Browser action 可以使用<code>chrome.runtime.sendMessage()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrome.tabs.sendMessage(</span><br><span class="line">    tabs[<span class="number">0</span>].id, <span class="comment">//当前激活的tab页id</span></span><br><span class="line">    &#123;<span class="attr">greeting</span>: <span class="string">"hello"</span>&#125;, <span class="comment">//需要传递的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123; <span class="comment">//用来接收反馈的回调函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(response.farewell);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Content Script完成初始化，设置<code>chrome.runtime.onMessage().addListener()</code>监听事件，等待另一侧请求信息的发布</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chrome.runtime.onMessage.addListener(</span><br><span class="line"> <span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(sender.tab ?</span><br><span class="line">                 <span class="string">"from a content script:"</span> + sender.tab.url :</span><br><span class="line">                 <span class="string">"from the extension"</span>);</span><br><span class="line">     <span class="keyword">if</span> (request.greeting == <span class="string">"hello"</span>)</span><br><span class="line">     sendResponse(&#123;<span class="attr">farewell</span>: <span class="string">"goodbye"</span>&#125;);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Content Script将信息通过Message发布订阅的方式，发布出去</p>
</li>
<li>Page action 或Browser action 中的js<code>chrome.tabs.sendMessage()</code>最后一个参数是一个回调函数，用来接收另一侧反馈回来的数据，最后同步到UI上<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome.tabs.sendMessage()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Content script有两种注入方式：编程式动态注入、声明式注入</p>
</li>
<li><p>编程式动态注入：获取<code>activeTab</code>权限后，使用<code>chrome.tabs.executeScript()</code>来注入js代码片段，使用<code>chrome.tabs.insertCSS()</code>注入css代码片段</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"My extension"</span>,</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"permissions"</span>: [</span><br><span class="line">    <span class="string">"activeTab"</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>  在Page action 或Browser action 中的js中实行编程式动态注入content script，其访问和更改的就是web page上的DOM属性</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">chrome.runtime.onMessage.addListener(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">message, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message == “changeColor”)&#123;</span><br><span class="line">      chrome.tabs.executeScript(&#123;</span><br><span class="line">        code: <span class="string">'document.body.style.backgroundColor="orange"'</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">// 你也可以注入一个文件</span></span><br><span class="line"> chrome.runtime.onMessage.addListener(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">message, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message == “runContentScript”)&#123;</span><br><span class="line">      chrome.tabs.executeScript(&#123;</span><br><span class="line">        file: <span class="string">'contentScript.js'</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>声明式注入，在manifest.json中使用content_scripts来定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"My extension"</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"content_scripts"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"matches"</span>: [<span class="string">"http://*.nytimes.com/*"</span>],</span><br><span class="line">        <span class="string">"css"</span>: [<span class="string">"myStyles.css"</span>],</span><br><span class="line">        <span class="string">"js"</span>: [<span class="string">"contentScript.js"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>matches：必填 数组，用来匹配注入Content Script的页面地址。可以使用通配符来指代：’*’指代任意长度字符；’?’指代单个字符</li>
<li>css：选填 数组，在页面的任何DOM创建和展示之前，按照数组中定义的顺序，依次注入</li>
<li>js：选填 数组，按照数组中定义的顺序，依次注入</li>
<li>run_at：Content Script注入的时机<ul>
<li>如果是document_start, 文件将在所有CSS加载完毕，但是没有创建DOM并且没有运行任何脚本的时候注入</li>
<li>如果是document_end，则文件将在创建完DOM之后，但还没有加载类似于图片或frame等的子资源前立刻注入</li>
<li>如果是document_idle，浏览器会在document_end和发出window.onload事件之间的某个时机注入。具体的时机取决与文档加载的复杂度，为加快页面加载而优化</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"content_scripts"</span> : [&#123;</span><br><span class="line">      <span class="string">"matches"</span> : [<span class="string">"*://*/*"</span>],</span><br><span class="line">      <span class="string">"js"</span> : [<span class="string">"content.js"</span>, <span class="string">"jquery.js"</span>],</span><br><span class="line">      <span class="string">"css"</span> : [<span class="string">"style.css"</span>],</span><br><span class="line">      <span class="string">"run_at"</span> : <span class="string">"document_end"</span></span><br><span class="line">  &#125;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>options_page 设置插件的选项页面，配置了此选项后，在插件上鼠标右键时，会有一个‘选项’按钮，点击后会进入options_page对应的页面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"options_page"</span>:<span class="string">"options.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g0s6ny6sqgj20hs0bagm8.jpg" alt=""></p>
</li>
<li><p>chrome_url_overrides 设置可替换的chrome默认页面</p>
<ul>
<li>newtab：新建标签时打开的页面</li>
<li>bookmarks：书签页面</li>
<li>history：历史记录<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"chrome_url_overrides"</span>:&#123;</span><br><span class="line">      <span class="string">"newtab"</span>: <span class="string">"newTab.html"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g0s8jgnb5ej2122068q3h.jpg" alt=""></p>
<h3 id="常用到的Chrome-API"><a href="#常用到的Chrome-API" class="headerlink" title="常用到的Chrome API"></a>常用到的Chrome API</h3><h4 id="chrome-tabs"><a href="#chrome-tabs" class="headerlink" title="chrome.tabs"></a>chrome.tabs</h4></li>
</ul>
<ol>
<li>chrome.tabs.create(object createProperties, function callback)<br>创建新的标签。注： 无需请求manifest的标签权限，此方法也可以被使用。<br><strong>Parameters</strong><br>createProperties ( object )<ul>
<li>windowId ( optional integer )<br>创建新标签的目标窗口。默认是当前窗口 。</li>
<li>index ( optional integer )<br>标签在窗口中的位置。 值在零至标签数量之间。</li>
<li>url ( optional string )<br>标签导航的初始页面。完整的URL 必须包含一个前缀 (如 ‘<a href="http://www.google.com&#39;" target="_blank" rel="noopener">http://www.google.com&#39;</a>, 不能写为 ‘<a href="http://www.google.com&#39;)。" target="_blank" rel="noopener">www.google.com&#39;)。</a> 相对 URL则与扩展所在的页面相对， 默认值为新标签页面。</li>
<li>selected ( optional boolean )<br>标签是否成为选中标签。默认为true。</li>
<li>pinned ( optional boolean )<br>标签是否被固定。默认值为false。</li>
<li>callback ( optional function )</li>
</ul>
</li>
</ol>
<pre><code>Callback function
回调 参数 应该如下定义：

function(Tab tab) {...};
tab ( Tab )
所创建的标签的细节，包含新标签的ID。
</code></pre><p><br></p>
<ol start="2">
<li><p>chrome.tabs.executeScript(integer tabId, object details, function callback)<br>向页面注入JavaScript 脚本执行<br><strong>Parameters</strong></p>
<ol>
<li>tabId ( optional integer )<br>运行脚本的标签ID；默认为当前窗口所选中的标签。</li>
<li>details ( object )<br>要执行的脚本内容，可选code或者file，但不能同时选两者。<ul>
<li>code ( optional string )<br>要执行的脚本代码。</li>
<li>file ( optional string )<br>要执行的脚本文件。</li>
<li>allFrames ( optional boolean )<br>true的时候，给所有frame执行脚本。默认为false，只给顶级frame执行脚本。</li>
</ul>
</li>
<li>callback ( optional function )<br>所有脚本执行后会被调用的回调。</li>
</ol>
</li>
<li><p>chrome.tabs.query(object queryInfo, function callback)<br>获取经过特定过滤条件筛选的标签页信息，如果没有特定过滤条件则是获取所有标签页信息</p>
<ol>
<li><p>queryInfo 为特定的属性，用来对标签页进行过滤。<br> 常用的属性有：（所有属性均为boolean值）</p>
<ul>
<li>active 标签在他们的窗口中是否是激活状态</li>
<li><p>currentWindow 标签是否在当前窗口</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrome.tabs.query(&#123;</span><br><span class="line">    active:<span class="literal">true</span>,</span><br><span class="line">    currentWindow:<span class="literal">true</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>callback 是获取到特定标签页信息后的回调函数，参数为标签的信息</p>
<h4 id="chrome-contextMenus-当前页面，选中内容后右键展示的内容"><a href="#chrome-contextMenus-当前页面，选中内容后右键展示的内容" class="headerlink" title="chrome.contextMenus 当前页面，选中内容后右键展示的内容"></a>chrome.contextMenus 当前页面，选中内容后右键展示的内容</h4><p><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g0whlgg7g5j20ba0eiwl4.jpg" alt=""></p>
</li>
</ol>
</li>
<li>在manifest.json中设置权限<code>{&quot;permissions&quot;: [&quot;contextMenus&quot;, &quot;storage&quot;]}</code></li>
<li>放在background.js中，初始化之后的回调函数中，使用<code>chrome.contextMenus.create({})</code>创建内容目录<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chrome.runtime.onInstalled.addListener(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">     chrome.contextMenus.create(&#123;</span><br><span class="line">         <span class="string">"id"</span>: <span class="string">"sampleContextMenu"</span>,</span><br><span class="line">         <span class="string">"title"</span>: <span class="string">"Sample Context Menu"</span>,</span><br><span class="line">         <span class="string">"contexts"</span>: [<span class="string">"selection"</span>]</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><ol>
<li>进入扩展程序管理界面 chrome://extensions</li>
<li>开启’开发者模式’<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g0s8xyee82j227k060t9t.jpg" alt=""></li>
<li>可以选择’加载已解压的扩展程序’，将本地开发目录上传上去即可</li>
<li>可以使用’打包扩展程序’，生成.ctx后缀的扩展程序，就可以发布到google应用市场了<h3 id="插件调试"><a href="#插件调试" class="headerlink" title="插件调试"></a>插件调试</h3><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4></li>
</ol>
<ul>
<li>每次刷新页面，都会执行browser_action或page_action 指定的popup.html资源</li>
<li>background指定的js资源只在插件安装时执行，之后就一直存在进程中，不会重复执行<h4 id="调试步骤"><a href="#调试步骤" class="headerlink" title="调试步骤"></a>调试步骤</h4></li>
</ul>
<ol>
<li>在浏览器工具栏右键插件图标<br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g0s91fijjaj20hs0ba3z4.jpg" alt=""></li>
<li>点击’审查弹出内容’，进入控制台</li>
<li>切换到Source栏，即可看到browser_action或page_action 指定的资源，设置断点</li>
<li>切换到Console栏，输入location.reload()，发现原有的页面重新进行了加载，同时browser_action或page_action 指定的资源也重新执行了一遍，并在设置的断点处停下来，等待debug</li>
</ol>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://developer.chrome.com/extensions" target="_blank" rel="noopener">chrome扩展程序</a><br><a href="https://www.zhihu.com/question/20179805" target="_blank" rel="noopener">如何从零写一个Chrome扩展</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://huanchong.top/2019/02/25/understanding-es6-12/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Huanchong Zhang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huanchong's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/25/understanding-es6-12/" class="post-title-link" itemprop="url">ES6-Modules</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-25 14:44:01" itemprop="dateCreated datePublished" datetime="2019-02-25T14:44:01+08:00">2019-02-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-04 15:11:45" itemprop="dateModified" datetime="2019-03-04T15:11:45+08:00">2019-03-04</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g0qs1z3avzj216w0lggpe.jpg" alt=""></p>
<h3 id="模块的导入导出"><a href="#模块的导入导出" class="headerlink" title="模块的导入导出"></a>模块的导入导出</h3><ol>
<li><p>导出export</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">111</span> <span class="comment">//导出基本类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;&#125; <span class="comment">// 导出函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1*num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; multiply &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入import</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; num &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span> <span class="comment">//导入单个模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Example <span class="keyword">from</span> <span class="string">'./example.js'</span> <span class="comment">//导入所有模块并合并在一个命名空间对象上</span></span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li><p>当代码执行到import导入语句时，会根据引用的路径，执行导出模块的代码，也就是完成导出模块的实例化，并且将该模块实例保存在内存中，同一应用的任何模块引用此导出模块时，都会复用已在内存中的模块实例，而不会重新进行导出模块的实例化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多次import同一模块，只在实例化一次模块，之后都会复用这个模块实例</span></span><br><span class="line"><span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;multiply&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;add&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入的常量是导出变量的只读引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; num &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span> <span class="comment">// 不能给num重新赋值，同时当example.js中的num值变化时，这里的num也会跟着变化</span></span><br><span class="line">num = <span class="string">'Tom'</span> <span class="comment">//error报错</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>重命名导入和导出名称</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="keyword">export</span> &#123;sum <span class="keyword">as</span> add&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 引入模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;add <span class="keyword">as</span> sum &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导出模块默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> add</span><br><span class="line"><span class="comment">//法三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>, multiply&#125; <span class="comment">//导出多个，并设置默认导出</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入模块默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">'./example.js'</span> <span class="comment">//不适用大括号&#123;&#125;，名字也可以随便取</span></span><br><span class="line"><span class="keyword">import</span> sum ,&#123; multiply &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span> <span class="comment">// 既有默认值sum，也有非默认值，非默认值要放到&#123;&#125;中，并且名称要和导出模块的名称保持一致</span></span><br><span class="line"><span class="comment">//上面的写法等价于下面的写法</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> sum, multiply&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入再导出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"><span class="keyword">export</span> &#123; add &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并到一句的写法：</span></span><br><span class="line"><span class="keyword">export</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"><span class="comment">//从example.js中导入add，并命名为sum导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; add <span class="keyword">as</span> sum &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>无绑定的导入(比如css文件等，不需要明确指定引入的模块内容)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Web浏览器中模块执行的顺序"><a href="#Web浏览器中模块执行的顺序" class="headerlink" title="Web浏览器中模块执行的顺序"></a>Web浏览器中模块执行的顺序</h3><p>新型浏览器针对script标签增加type=’module’的属性，来支持模块化语法的资源引入</p>
<ol>
<li>遇到<code>&lt;script type=&#39;module&#39;&gt;</code> 的标签时，会立即下载对应的js资源，下载完后会解析js，遇到import语句会取请求对应的资源</li>
<li>下载和解析<code>&lt;script type=&#39;module&#39;&gt;</code> 资源的时候，并不会影响html接下来的解析</li>
<li>在html解析加载完成之前只会做下载和解析工作，不会执行js代码，执行js的顺序会严格按照<code>&lt;script&gt;</code>显式引入和import隐式引入的顺序来依次执行<h4 id="案例分析："><a href="#案例分析：" class="headerlink" title="案例分析："></a>案例分析：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">'module'</span> src=<span class="string">'module1.js'</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">'module'</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line">    <span class="keyword">let</span> result = sum(<span class="number">1</span>,<span class="number">2</span>) </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script type='module' src='module2.js'&gt;&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>正确的顺序：</p>
<ol>
<li>下载并解析module1.js</li>
<li>递归下载并解析在module1.js中使用import引入的资源</li>
<li>解析内联模块</li>
<li>递归下载并解析内联模块中使用import引入的资源example.js</li>
<li>下载并解析module2.js<br>在html解析完成之前，都不会有任何JS执行，当html解析完成之后，DOMContentLoaded触发之前，开始执行js，执行js的顺序如下：</li>
<li>递归执行module1.js中引入的资源(按照import的顺序依次执行)</li>
<li>执行module1.js</li>
<li>递归执行内联模块import的资源</li>
<li>执行内联模块的代码</li>
<li>递归执行module2.js中引入的资源(按照import的顺序依次执行)</li>
<li>执行module2.js</li>
</ol>
<p>注意：<code>&lt;script type=&#39;module&#39;&gt;&lt;/script&gt;</code>采取的就是defer属性的方式，因此设不设置defer没有任何影响；但是设置async属性后，会<strong>按照async的模式，下载解析完，并且所有包含的import资源也都下载解析后按照引入顺序立即执行js</strong><br><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g0iwdd6h68j227m0j642z.jpg" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://huanchong.top/2019/02/24/understanding-es6-11/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Huanchong Zhang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huanchong's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/24/understanding-es6-11/" class="post-title-link" itemprop="url">ES6-Promise</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-24 15:06:44" itemprop="dateCreated datePublished" datetime="2019-02-24T15:06:44+08:00">2019-02-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-04 15:11:38" itemprop="dateModified" datetime="2019-03-04T15:11:38+08:00">2019-03-04</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g0qs1z3avzj216w0lggpe.jpg" alt=""></p>
<h3 id="Promise与异步编程"><a href="#Promise与异步编程" class="headerlink" title="Promise与异步编程"></a>Promise与异步编程</h3><h4 id="创建一个待执行状态的Promise"><a href="#创建一个待执行状态的Promise" class="headerlink" title="创建一个待执行状态的Promise"></a>创建一个待执行状态的Promise</h4><p>new Promise()会立即执行，因此如果需要在合适的位置创建Promise，可以使用一个函数进行包装，合适的位置进行调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//异步操作</span></span><br><span class="line">        fs.readFile(fileName, (err, contents)=&gt; &#123;</span><br><span class="line">            <span class="comment">//读取错误时</span></span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                reject(err)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//读取成功时</span></span><br><span class="line">            resolve(contents)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> file = readFile(<span class="string">'readme.txt'</span>)</span><br><span class="line"><span class="comment">// 同时监听成功或失败</span></span><br><span class="line">file.then(<span class="function"><span class="params">data</span> =&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="直接返回一个已执行状态的Promise对象"><a href="#直接返回一个已执行状态的Promise对象" class="headerlink" title="直接返回一个已执行状态的Promise对象"></a>直接返回一个已执行状态的Promise对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line"><span class="built_in">Promise</span>.reject()</span><br></pre></td></tr></table></figure>
<ul>
<li>传递给Promise.resolve()的参数，如果是一个Promise对象，则会原样返回，如果不是一个Promise对象，针对非Promise的thenable对象，会做进一步包装，将其转换成Promise对象再返回（基本类型的值也会被自动转换成Promise对象）</li>
<li><p>非Promise的thenable对象：具有接受resolve、reject参数的then()方法的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">    then(resolve,reject)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'enter thenable'</span>)</span><br><span class="line">        resolve(<span class="number">42</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before then'</span>)</span><br><span class="line">p1.then(<span class="function"><span class="params">data</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">before then</span></span><br><span class="line"><span class="comment">enter thenable</span></span><br><span class="line"><span class="comment">42</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上例中<br>1.程序按顺序执行，遇到<code>Promise.resolve(thenable)</code>时会把thenable中的then()中的异步函数放入microtask队列中，等主程序执行完后调用</p>
<ol start="2">
<li>执行<code>console.log(&#39;before then&#39;)</code></li>
<li>执行p1.then()这里，监听p1的状态，一旦由pending变为resolve或reject，便将其放入microtask队列中，在主程序执行完后执行</li>
<li>因此先打印<code>before then</code>，然后再打印<code>enter thenable</code>，最后是<code>42</code></li>
</ol>
</li>
</ul>
<h4 id="then-、catch-执行完后都会返回一个Promise对象，如果没有显式指定return，则会返回一个默认的Promise"><a href="#then-、catch-执行完后都会返回一个Promise对象，如果没有显式指定return，则会返回一个默认的Promise" class="headerlink" title="then()、catch()执行完后都会返回一个Promise对象，如果没有显式指定return，则会返回一个默认的Promise"></a>then()、catch()执行完后都会返回一个Promise对象，如果没有显式指定return，则会返回一个默认的Promise</h4><h4 id="响应多个Promise"><a href="#响应多个Promise" class="headerlink" title="响应多个Promise"></a>响应多个Promise</h4><ol>
<li><p>Promise.all([, , ,])参数是一个可迭代的对象(常用数组)，每个元素都是Promise对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'p1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'p2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'p3'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line">p4.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value)) <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)  <span class="comment">//["p1", "p2", "p3"]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>Promise.all([]).then()</code>then()中的参数是一个数组，成员是你传入的多个Promise对象中resolve的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'p1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'p2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'p3'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line">p4.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value)) <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)  <span class="comment">//["p1", "p2", "p3"]</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'err'</span>,err)</span><br><span class="line">     &#125;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<p>如果Promise对象中触发reject状态，则会立即触发<code>Promise.all([]).catch()</code>catch()中的参数是触发reject()返回的值</p>
</li>
<li><p>Promise.race([, , ,]) 多个Promise对象竞赛，谁先触发状态变化，立刻停止</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'p1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> <span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">'p2'</span>)</span><br><span class="line"> <span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     resolve(<span class="string">'p3'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1, p2, p3])</span><br><span class="line"> p4.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(value)  </span><br><span class="line"> &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'err'</span>,err)</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="comment">// p1</span></span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://huanchong.top/2019/02/24/understanding-es6-10/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Huanchong Zhang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huanchong's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/24/understanding-es6-10/" class="post-title-link" itemprop="url">ES6-Array</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-24 13:42:09" itemprop="dateCreated datePublished" datetime="2019-02-24T13:42:09+08:00">2019-02-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-04 15:11:34" itemprop="dateModified" datetime="2019-03-04T15:11:34+08:00">2019-03-04</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g0qs1z3avzj216w0lggpe.jpg" alt=""></p>
<h3 id="对数组功能的增强"><a href="#对数组功能的增强" class="headerlink" title="对数组功能的增强"></a>对数组功能的增强</h3><h4 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h4><ol>
<li><p>Array.of()<br>数组构造器new Array()创建数组时，因为传递参数的个数与类型不同，会出现怪异的行为，因此引进了Array.of()方法创建数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>) <span class="comment">//如果只有一个参数，并且是数值型，new Array()构造器就把参数理解成为数组的长度，所以元素都为undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]) <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"> items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>,<span class="number">1</span>) <span class="comment">//如果参数超过1个，则new Array()构造器就把参数理解成为数组的元素</span></span><br><span class="line"> <span class="built_in">console</span>.log(items[<span class="number">0</span>]) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>])  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以这里作为对参数理解的统一，使用Array.of()都会把参数理解成为元素</span></span><br><span class="line">items = <span class="built_in">Array</span>.of(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.from()<br>将类数组对象(具有数值类型的索引+length长度属性，比如DOM的NodeList)转换成数组类型<br>传统的比较快捷的方法是使用slice</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike)</span><br></pre></td></tr></table></figure>
<p>ES6提供的解决方法Array.from()，支持将<strong>类数组对象、可迭代对象(包含Symbol.iterator属性)</strong>转换成数组类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="数组实例的新方法"><a href="#数组实例的新方法" class="headerlink" title="数组实例的新方法"></a>数组实例的新方法</h4><ol>
<li><p>find()\findIndex() 根据过滤条件返回想要的第一个满足条件的元素值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">12</span>,<span class="number">20</span>,<span class="number">33</span>,<span class="number">45</span>]</span><br><span class="line"><span class="keyword">let</span> value = numbers.find(<span class="function"><span class="params">value</span> =&gt;</span> value&gt;<span class="number">30</span>)</span><br><span class="line"><span class="keyword">let</span> index = numbers.findIndex(<span class="function"><span class="params">value</span> =&gt;</span> value&gt;<span class="number">30</span>)</span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">//33</span></span><br><span class="line"><span class="built_in">console</span>.log(index) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>fill()数组元素的赋值填充，第一个必填参数为想要赋新值的元素，支持指定第二、第三个参数表示赋值开始和结束的位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">arr.fill(<span class="number">1</span>) <span class="comment">//将元素全部重新赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">//1,1,1,1</span></span><br><span class="line">arr.fill(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">//1,0,0,0</span></span><br><span class="line">arr.fill(<span class="number">10</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">//1,10,10,0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>copyWithin()允许在数组内部复制自身的元素</p>
<h4 id="类型化数组"><a href="#类型化数组" class="headerlink" title="类型化数组"></a>类型化数组</h4><p>不是严格意义上的数组，主要是为JS提供快速按位计算的能力，fill()\copyWithin()方法都是基于此创建的，平时使用的场景比较少，感兴趣的可以继续了解下</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://huanchong.top/2019/02/22/understanding-es6-9/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Huanchong Zhang"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huanchong's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/22/understanding-es6-9/" class="post-title-link" itemprop="url">ES6-Class</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-22 10:54:41" itemprop="dateCreated datePublished" datetime="2019-02-22T10:54:41+08:00">2019-02-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-04 15:11:24" itemprop="dateModified" datetime="2019-03-04T15:11:24+08:00">2019-03-04</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://ws1.sinaimg.cn/large/e4d30300ly1g0qs1z3avzj216w0lggpe.jpg" alt=""></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在ES6之前，官方都不支持类的语法，很多第三方类库都通过模拟实现了类似类的用法，最终ES6引入了类</p>
<h3 id="类的介绍"><a href="#类的介绍" class="headerlink" title="类的介绍"></a>类的介绍</h3><h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><h5 id="ES6之前的写法：称为自定义类型"><a href="#ES6之前的写法：称为自定义类型" class="headerlink" title="ES6之前的写法：称为自定义类型"></a>ES6之前的写法：称为自定义类型</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ES6的写法："><a href="#ES6的写法：" class="headerlink" title="ES6的写法："></a>ES6的写法：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name <span class="comment">//自有属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.sayName()) <span class="comment">//Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person) <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.sayName) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype.sayName) <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>console.log(typeof Person) //function</code> 通过打印结果可以看到，ES6对类的声明类似ES5自定义类型写法的语法糖，本质上class定义的Person仍然是一个函数</li>
<li><code>console.log(typeof Person.sayName) //undefined  console.log(typeof Person.prototype.sayName) //function</code> 通过打印结果可以看到，ES6类中声明的方法实际也是挂载到原型上的，这个ES5自定义类型中定义的方法是一样的</li>
</ul>
<p>类表达式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name <span class="comment">//自有属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具名类表达式</span></span><br><span class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name <span class="comment">//自有属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">**这里的Person2只能在类的方法中被访问到**</span><br></pre></td></tr></table></figure></p>
<h5 id="使用ES6声明类的优势"><a href="#使用ES6声明类的优势" class="headerlink" title="使用ES6声明类的优势"></a>使用ES6声明类的优势</h5><ol>
<li>类声明不会被提升，类声明类似于let，在程序执行到达类声明之前，是处于暂时性死区中的，访问会报错。ES5中的函数定义法，函数是可以被提升到当前作用域顶部的</li>
<li>类声明中的代码强制在严格模式下运行’use strict’，且不能退出</li>
<li>类的所有方法不可枚举，ES5的自定义类型只能通过Object.defineProperty()来定义属性描述符规定其不可枚举</li>
<li>调用类生成实例时，必须使用new关键词，会自动调用类中的构造器constructor函数。不适用new 调用类会报错；这是自定义类型的函数是没办法规避的</li>
<li>类的方法不能使用new 关键词调用，会抛出错误</li>
<li>试图在类的方法中重写类名(相当于const类名)，会抛出错误；在类外部可以重写类名(相当于let类名)</li>
</ol>
<h4 id="类是一等公民"><a href="#类是一等公民" class="headerlink" title="类是一等公民"></a>类是一等公民</h4><p>在编程中，能被当做值来使用的就称为一等公民，也就是说，就像函数那样，能够作为函数的参数、函数的返回值、能用来给变量赋值等操作<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClass</span>(<span class="params">classDef</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> classDef()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = createClass(<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    sayHi()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.sayHi() <span class="comment">//Hi</span></span><br></pre></td></tr></table></figure></p>
<h4 id="类的访问器属性"><a href="#类的访问器属性" class="headerlink" title="类的访问器属性"></a>类的访问器属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = name</span><br><span class="line">    &#125;</span><br><span class="line">    get name()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getter'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">    set name(name)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setter'</span>)</span><br><span class="line">        <span class="keyword">this</span>.value = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br><span class="line">person.name = <span class="string">'Lisa'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">getter</span></span><br><span class="line"><span class="comment">Tom</span></span><br><span class="line"><span class="comment">setter</span></span><br><span class="line"><span class="comment">getter</span></span><br><span class="line"><span class="comment">Lisa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="为类添加生成器方法-定义Symbol-iterator"><a href="#为类添加生成器方法-定义Symbol-iterator" class="headerlink" title="为类添加生成器方法(定义Symbol.iterator)"></a>为类添加生成器方法(定义Symbol.iterator)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.items= []</span><br><span class="line">    &#125;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="keyword">yield</span> *<span class="keyword">this</span>.items.values() <span class="comment">//this.items.values()是数组内置的迭代器，这里相当于把this.items的生成器合并在类生成器中了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> collection = <span class="keyword">new</span> Collection()</span><br><span class="line">collection.items.push(<span class="number">1</span>)</span><br><span class="line">collection.items.push(<span class="number">2</span>)</span><br><span class="line">collection.items.push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> collection)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>我们之前已经实验过，在类中定义的方法，是把此方法属性加到类的原型上的，类的实例也都继承了这些方法，可以访问；<br>如果不希望实例可以访问，只能被类自身访问，则需要使用静态成员</p>
<h5 id="ES5传统的实现写法"><a href="#ES5传统的实现写法" class="headerlink" title="ES5传统的实现写法"></a>ES5传统的实现写法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加在原型上，所有实例都可以访问</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line">静态方法，实例访问不到</span><br><span class="line">Person.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ES6写法"><a href="#ES6写法" class="headerlink" title="ES6写法"></a>ES6写法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加到原型上，所有实例都可以访问</span></span><br><span class="line">    getName()&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> sayHi()&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'Hi'</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()) <span class="comment">//Tom</span></span><br><span class="line"><span class="comment">// person.sayHi() // 抛出异常 person.sayHi is not a function</span></span><br><span class="line">Person.sayHi()<span class="comment">//Hi</span></span><br></pre></td></tr></table></figure>
<h4 id="使用extends关键词完成类的继承"><a href="#使用extends关键词完成类的继承" class="headerlink" title="使用extends关键词完成类的继承"></a>使用extends关键词完成类的继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width)&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    getArea()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length)&#123;</span><br><span class="line">        <span class="comment">//使用super()调用父类的构造函数</span></span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea()) <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>继承父类的类叫派生类，派生类如果显式定义了构造器，就必须在访问this之前，要显式地使用super()调用父类的构造器，完成父类初始化this，并通过继承传递给派生类，否则在派生类中访问this时会报错</li>
<li><p>在派生类中才可以使用super关键词，指代父类，super()表示先初始化父类的构造器，然后派生类继承父类的this，所以在派生类中this也就可以访问了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'call parent'</span>)</span><br><span class="line">      <span class="keyword">this</span>.length = <span class="number">10</span></span><br><span class="line">      <span class="keyword">this</span>.width = <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">  getArea()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">      <span class="keyword">constructor</span>()&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'call child1'</span>)</span><br><span class="line">          <span class="keyword">super</span>()</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'call child2'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      getValue()&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'length'</span>,<span class="keyword">this</span>.length)</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'width'</span>,<span class="keyword">this</span>.width)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> square = <span class="keyword">new</span> Square()</span><br><span class="line">  square.getValue()</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  call child1</span></span><br><span class="line"><span class="comment">  call parent</span></span><br><span class="line"><span class="comment">  call child2</span></span><br><span class="line"><span class="comment">  length 10</span></span><br><span class="line"><span class="comment">  width 5</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果派生类没有显式定义构造器，则系统在初始化的时候会默认调用super()，并使用创建实例时传递的所有参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(..args)&#123;</span><br><span class="line">        <span class="keyword">super</span>(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注意：如果派生类与父类初始化的参数完全相同，可以选择省略constructor的形式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width)&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    getArea()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea()) <span class="comment">//9</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>如果派生类与父类的初始化参数不一致，就得自己写构造器constructor，手动调用super()，否则会得到意想不到的结果<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width)&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    getArea()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>) <span class="comment">//这里只传了1个参数，派生类使用默认的构造器传递参数，与父类构造器参数不一致，导致有些参数为undefined，调用计算方法是肯定为NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(square.getArea()) <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="静态成员也会被继承"><a href="#静态成员也会被继承" class="headerlink" title="静态成员也会被继承"></a>静态成员也会被继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> sayHi()&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'Hi'</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.sayHi()<span class="comment">//Hi </span></span><br><span class="line">Student.sayHi()<span class="comment">//Hi</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Huanchong Zhang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/haunchong" title="GitHub &rarr; https://github.com/haunchong" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:huanchong@gmail.com" title="E-Mail &rarr; mailto:huanchong@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=523042017&auto=1&height=66"></iframe>
    </div>

  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  
  <span class="author" itemprop="copyrightHolder">Huanchong Zhang</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=6.7.0"></script>




  

  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  




  





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
